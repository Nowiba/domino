<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Authentic Domino Game</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: #2c3e50;
            color: #ecf0f1;
            overflow-x: hidden;
            touch-action: manipulation;
        }

        #app {
            max-width: 100%;
            margin: 0 auto;
            padding: 10px;
            position: relative;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            padding: 15px 0;
            background-color: #3498db;
            color: white;
            border-radius: 8px;
            margin-bottom: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .game-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .board {
            background-color: #34495e;
            border-radius: 8px;
            padding: 15px;
            min-height: 200px;
            position: relative;
            overflow: auto;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.2);
            margin-bottom: 15px;
            border: 2px solid #2c3e50;
        }

        .domino-chain {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            min-height: 150px;
            padding: 20px;
            position: relative;
        }

        .domino {
            width: 60px;
            height: 120px;
            background-color: white;
            border-radius: 8px;
            margin: 10px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            position: relative;
            transition: all 0.3s ease;
            cursor: pointer;
            z-index: 2;
            border: 2px solid #bdc3c7;
        }

        .domino.horizontal {
            width: 120px;
            height: 60px;
            flex-direction: row;
            padding: 0 8px;
        }

        .domino.vertical {
            transform: rotate(90deg);
            margin: 30px 15px;
        }

        .domino.double {
            background-color: #fff3e0;
            border-color: #ffab91;
        }

        .domino.selected {
            transform: translateY(-20px) scale(1.1);
            box-shadow: 0 10px 20px rgba(0,0,0,0.4);
            z-index: 10;
            border-color: #e74c3c;
        }

        .domino .half {
            width: 100%;
            height: 50%;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            position: relative;
        }

        .domino.horizontal .half {
            width: 50%;
            height: 100%;
            flex-direction: row;
        }

        .domino .pip {
            width: 10px;
            height: 10px;
            background-color: #2c3e50;
            border-radius: 50%;
            flex-shrink: 0;
            box-shadow: inset 0 0 3px rgba(0,0,0,0.3);
        }

        .domino .divider {
            width: 90%;
            height: 3px;
            background-color: #bdc3c7;
            border-radius: 3px;
        }

        .domino.horizontal .divider {
            width: 3px;
            height: 90%;
        }

        .domino-connector {
            width: 20px;
            height: 4px;
            background: #7f8c8d;
            margin: 0 -2px;
            z-index: 1;
            position: absolute;
        }

        .player-area {
            background-color: #3498db;
            border-radius: 8px;
            padding: 15px;
            color: white;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            margin-bottom: 15px;
            border: 2px solid #2980b9;
        }

        .player-hand {
            display: flex;
            gap: 10px;
            padding: 15px 0;
            overflow-x: auto;
            min-height: 140px;
            align-items: center;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.5) transparent;
        }

        .player-hand::-webkit-scrollbar {
            height: 8px;
        }

        .player-hand::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.5);
            border-radius: 4px;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            background-color: #e74c3c;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            flex-grow: 1;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            min-width: 120px;
            font-size: 16px;
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
            opacity: 0.7;
        }

        button:hover:not(:disabled) {
            background-color: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .game-status {
            text-align: center;
            margin: 15px 0;
            font-weight: bold;
            font-size: 1.2em;
            background-color: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 6px;
        }

        .scoreboard {
            display: flex;
            justify-content: space-around;
            background-color: #34495e;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .player-score {
            text-align: center;
            padding: 5px 10px;
            border-radius: 4px;
            background-color: rgba(255,255,255,0.1);
        }

        .player-score.active {
            background-color: #e74c3c;
            font-weight: bold;
        }

        .end-marker {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #e74c3c;
            border-radius: 50%;
            z-index: 5;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            cursor: pointer;
        }

        @media (max-width: 600px) {
            .domino {
                width: 50px;
                height: 100px;
            }
            
            .domino.horizontal {
                width: 100px;
                height: 50px;
            }
            
            button {
                padding: 10px 15px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="header">
            <h1>Authentic Domino Game</h1>
        </div>

        <div id="gameScreen" style="display: block;">
            <div class="scoreboard" id="scoreboard"></div>
            <div class="game-status" id="gameStatus">Your turn!</div>
            
            <div class="game-container">
                <div class="board">
                    <div class="domino-chain" id="dominoChain"></div>
                </div>

                <div class="player-area">
                    <h3>Your Hand</h3>
                    <div class="player-hand" id="playerHand"></div>
                    <div class="controls">
                        <button id="drawBtn">Draw from Boneyard</button>
                        <button id="passBtn" disabled>Pass Turn</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM elements
        const gameScreen = document.getElementById('gameScreen');
        const playerHand = document.getElementById('playerHand');
        const dominoChain = document.getElementById('dominoChain');
        const gameStatus = document.getElementById('gameStatus');
        const drawBtn = document.getElementById('drawBtn');
        const passBtn = document.getElementById('passBtn');
        const scoreboard = document.getElementById('scoreboard');

        // Game state
        let gameState = {
            players: [
                { id: 0, name: 'You', dominoes: [], score: 0, isHuman: true },
                { id: 1, name: 'Computer', dominoes: [], score: 0, isHuman: false }
            ],
            currentPlayer: 0,
            board: [],
            stock: [],
            openEnds: [],
            gameOver: false,
            winner: null
        };

        let playerDominoes = [];
        let isCurrentPlayer = false;
        let selectedDomino = null;
        let selectedEnd = null;

        // Initialize the game
        function init() {
            // Generate domino set
            const dominoSet = generateDominoSet();
            shuffleArray(dominoSet);

            // Deal dominoes (7 each for 2 players)
            gameState.players[0].dominoes = dominoSet.slice(0, 7);
            gameState.players[1].dominoes = dominoSet.slice(7, 14);
            gameState.stock = dominoSet.slice(14);

            // Determine who starts (player with highest double)
            let startingPlayer = 0;
            let highestDouble = -1;
            
            gameState.players.forEach((player, index) => {
                player.dominoes.forEach(domino => {
                    if (domino[0] === domino[1] && domino[0] > highestDouble) {
                        highestDouble = domino[0];
                        startingPlayer = index;
                    }
                });
            });
            
            // If no doubles, player with highest sum domino starts
            if (highestDouble === -1) {
                let highestSum = -1;
                
                gameState.players.forEach((player, index) => {
                    player.dominoes.forEach(domino => {
                        const sum = domino[0] + domino[1];
                        if (sum > highestSum) {
                            highestSum = sum;
                            startingPlayer = index;
                        }
                    });
                });
            }

            gameState.currentPlayer = startingPlayer;
            isCurrentPlayer = gameState.players[startingPlayer].isHuman;

            // Update UI
            updateGameUI();

            // If computer starts, make a move
            if (!isCurrentPlayer) {
                setTimeout(computerMove, 1000);
            }

            // Set up event listeners
            drawBtn.addEventListener('click', drawDomino);
            passBtn.addEventListener('click', passTurn);
        }

        // Update game UI
        function updateGameUI() {
            // Update scoreboard
            updateScoreboard();
            
            // Update game status
            const currentPlayer = gameState.players[gameState.currentPlayer];
            if (currentPlayer.isHuman) {
                gameStatus.textContent = 'Your turn!';
                gameStatus.style.color = '#2ecc71';
            } else {
                gameStatus.textContent = `${currentPlayer.name}'s turn`;
                gameStatus.style.color = '#ecf0f1';
            }
            
            // Update board
            renderBoard();
            
            // Update player's hand
            playerDominoes = gameState.players[0].dominoes;
            updatePlayerHand();
            
            // Update buttons
            drawBtn.disabled = !isCurrentPlayer || gameState.stock.length === 0;
            passBtn.disabled = !isCurrentPlayer || !canPass();
        }

        // Update scoreboard
        function updateScoreboard() {
            scoreboard.innerHTML = '';
            
            gameState.players.forEach((player, index) => {
                const playerScore = document.createElement('div');
                playerScore.className = `player-score ${index === gameState.currentPlayer ? 'active' : ''}`;
                playerScore.innerHTML = `
                    <div>${player.name}</div>
                    <div>${player.score} pts</div>
                `;
                scoreboard.appendChild(playerScore);
            });
        }

        // Render the game board
        function renderBoard() {
            dominoChain.innerHTML = '';
            
            // Create a central starting point
            const centerX = dominoChain.offsetWidth / 2;
            const centerY = dominoChain.offsetHeight / 2;
            
            // Render all dominoes on the board
            gameState.board.forEach(domino => {
                const dominoEl = createDominoElement(domino.value, domino.orientation);
                dominoEl.style.position = 'absolute';
                dominoEl.style.left = `${domino.x}px`;
                dominoEl.style.top = `${domino.y}px`;
                dominoEl.style.transform = domino.orientation === 'vertical' ? 'rotate(90deg)' : '';
                dominoChain.appendChild(dominoEl);
            });
            
            // Render open ends
            gameState.openEnds.forEach((end, index) => {
                const endMarker = document.createElement('div');
                endMarker.className = 'end-marker';
                endMarker.textContent = end.value;
                endMarker.style.left = `${end.x}px`;
                endMarker.style.top = `${end.y}px`;
                endMarker.dataset.endIndex = index;
                
                if (isCurrentPlayer) {
                    endMarker.style.cursor = 'pointer';
                    endMarker.addEventListener('click', () => {
                        if (selectedDomino !== null) {
                            placeDomino(selectedDomino, index);
                        }
                    });
                }
                
                dominoChain.appendChild(endMarker);
            });
        }

        // Update player's hand
        function updatePlayerHand() {
            playerHand.innerHTML = '';
            
            playerDominoes.forEach((domino, index) => {
                const dominoEl = createDominoElement(domino);
                dominoEl.dataset.index = index;
                
                if (isCurrentPlayer) {
                    dominoEl.style.cursor = 'pointer';
                    dominoEl.addEventListener('click', () => {
                        // Deselect previous selection
                        if (selectedDomino !== null) {
                            playerHand.children[selectedDomino].classList.remove('selected');
                        }
                        
                        // Select this domino
                        selectedDomino = index;
                        dominoEl.classList.add('selected');
                    });
                }
                
                playerHand.appendChild(dominoEl);
            });
        }

        // Create a domino element
        function createDominoElement(domino, orientation = 'horizontal') {
            const dominoEl = document.createElement('div');
            dominoEl.className = `domino ${orientation}`;
            
            if (domino[0] === domino[1]) {
                dominoEl.classList.add('double');
            }
            
            // Create left half
            const leftHalf = document.createElement('div');
            leftHalf.className = 'half';
            createPips(leftHalf, domino[0]);
            
            // Create divider
            const divider = document.createElement('div');
            divider.className = 'divider';
            
            // Create right half
            const rightHalf = document.createElement('div');
            rightHalf.className = 'half';
            createPips(rightHalf, domino[1]);
            
            dominoEl.appendChild(leftHalf);
            dominoEl.appendChild(divider);
            dominoEl.appendChild(rightHalf);
            
            return dominoEl;
        }

        // Create pips for a domino half
        function createPips(container, value) {
            if (value === 0) return;
            
            // Create appropriate pip configuration based on value
            switch(value) {
                case 1:
                    container.innerHTML = '<div class="pip"></div>';
                    break;
                case 2:
                    container.innerHTML = `
                        <div style="align-self: flex-start;" class="pip"></div>
                        <div style="align-self: flex-end;" class="pip"></div>
                    `;
                    break;
                case 3:
                    container.innerHTML = `
                        <div style="align-self: flex-start;" class="pip"></div>
                        <div style="align-self: center;" class="pip"></div>
                        <div style="align-self: flex-end;" class="pip"></div>
                    `;
                    break;
                case 4:
                    container.innerHTML = `
                        <div style="display: flex; justify-content: space-between; width: 100%;">
                            <div class="pip"></div>
                            <div class="pip"></div>
                        </div>
                        <div style="display: flex; justify-content: space-between; width: 100%;">
                            <div class="pip"></div>
                            <div class="pip"></div>
                        </div>
                    `;
                    break;
                case 5:
                    container.innerHTML = `
                        <div style="display: flex; justify-content: space-between; width: 100%;">
                            <div class="pip"></div>
                            <div class="pip"></div>
                        </div>
                        <div style="display: flex; justify-content: center; width: 100%;">
                            <div class="pip"></div>
                        </div>
                        <div style="display: flex; justify-content: space-between; width: 100%;">
                            <div class="pip"></div>
                            <div class="pip"></div>
                        </div>
                    `;
                    break;
                case 6:
                    container.innerHTML = `
                        <div style="display: flex; justify-content: space-between; width: 100%;">
                            <div class="pip"></div>
                            <div class="pip"></div>
                        </div>
                        <div style="display: flex; justify-content: space-between; width: 100%;">
                            <div class="pip"></div>
                            <div class="pip"></div>
                        </div>
                        <div style="display: flex; justify-content: space-between; width: 100%;">
                            <div class="pip"></div>
                            <div class="pip"></div>
                        </div>
                    `;
                    break;
            }
        }

        // Place a domino on the board
        function placeDomino(dominoIndex, endIndex) {
            const domino = playerDominoes[dominoIndex];
            const end = gameState.openEnds[endIndex];
            
            // Check if domino can connect to this end
            if (domino[0] !== end.value && domino[1] !== end.value) return;
            
            // Rotate domino if needed
            const rotatedDomino = domino[0] === end.value ? domino : [domino[1], domino[0]];
            
            // Calculate position based on end position
            const centerX = dominoChain.offsetWidth / 2;
            const centerY = dominoChain.offsetHeight / 2;
            
            let x, y, orientation;
            
            if (gameState.board.length === 0) {
                // First domino goes in the center
                x = centerX - 60;
                y = centerY - 60;
                orientation = 'horizontal';
                
                // Set up initial open ends
                gameState.openEnds = [
                    { value: rotatedDomino[0], x: x - 30, y: y + 60 },
                    { value: rotatedDomino[1], x: x + 150, y: y + 60 }
                ];
            } else {
                // Place relative to the end
                if (end.x < centerX) {
                    // Place to the left
                    x = end.x - 120;
                    y = end.y - 30;
                    orientation = 'horizontal';
                    gameState.openEnds.push({ value: rotatedDomino[0], x: x - 30, y: y + 30 });
                } else if (end.x > centerX + 100) {
                    // Place to the right
                    x = end.x;
                    y = end.y - 30;
                    orientation = 'horizontal';
                    gameState.openEnds.push({ value: rotatedDomino[1], x: x + 150, y: y + 30 });
                } else if (end.y < centerY) {
                    // Place above
                    x = end.x - 60;
                    y = end.y - 120;
                    orientation = 'vertical';
                    gameState.openEnds.push({ value: rotatedDomino[0], x: x + 60, y: y - 30 });
                } else {
                    // Place below
                    x = end.x - 60;
                    y = end.y;
                    orientation = 'vertical';
                    gameState.openEnds.push({ value: rotatedDomino[1], x: x + 60, y: y + 150 });
                }
                
                // Remove the used end
                gameState.openEnds.splice(endIndex, 1);
                
                // If it's a double, add both ends
                if (rotatedDomino[0] === rotatedDomino[1]) {
                    if (orientation === 'horizontal') {
                        gameState.openEnds.push(
                            { value: rotatedDomino[0], x: x + 60, y: y - 30 },
                            { value: rotatedDomino[1], x: x + 60, y: y + 90 }
                        );
                        orientation = 'vertical';
                    } else {
                        gameState.openEnds.push(
                            { value: rotatedDomino[0], x: x - 30, y: y + 60 },
                            { value: rotatedDomino[1], x: x + 90, y: y + 60 }
                        );
                        orientation = 'horizontal';
                    }
                }
            }
            
            // Add to board
            gameState.board.push({
                value: rotatedDomino,
                orientation,
                x,
                y
            });
            
            // Remove from player's hand
            gameState.players[0].dominoes.splice(dominoIndex, 1);
            selectedDomino = null;
            
            // Check for win
            if (gameState.players[0].dominoes.length === 0) {
                endGame(0);
                return;
            }
            
            // Switch to computer
            gameState.currentPlayer = 1;
            isCurrentPlayer = false;
            
            // Update UI
            updateGameUI();
            
            // Computer's turn
            setTimeout(computerMove, 1000);
        }

        // Computer makes a move
        function computerMove() {
            if (gameState.gameOver) return;
            
            const computer = gameState.players[1];
            let played = false;
            
            // Try to play a domino on any open end
            for (let endIndex = 0; endIndex < gameState.openEnds.length; endIndex++) {
                const end = gameState.openEnds[endIndex];
                
                for (let i = 0; i < computer.dominoes.length; i++) {
                    const domino = computer.dominoes[i];
                    
                    if (domino[0] === end.value || domino[1] === end.value) {
                        // Rotate domino if needed
                        const rotatedDomino = domino[0] === end.value ? domino : [domino[1], domino[0]];
                        
                        // Calculate position
                        const centerX = dominoChain.offsetWidth / 2;
                        const centerY = dominoChain.offsetHeight / 2;
                        
                        let x, y, orientation;
                        
                        if (end.x < centerX) {
                            // Place to the left
                            x = end.x - 120;
                            y = end.y - 30;
                            orientation = 'horizontal';
                            gameState.openEnds.push({ value: rotatedDomino[0], x: x - 30, y: y + 30 });
                        } else if (end.x > centerX + 100) {
                            // Place to the right
                            x = end.x;
                            y = end.y - 30;
                            orientation = 'horizontal';
                            gameState.openEnds.push({ value: rotatedDomino[1], x: x + 150, y: y + 30 });
                        } else if (end.y < centerY) {
                            // Place above
                            x = end.x - 60;
                            y = end.y - 120;
                            orientation = 'vertical';
                            gameState.openEnds.push({ value: rotatedDomino[0], x: x + 60, y: y - 30 });
                        } else {
                            // Place below
                            x = end.x - 60;
                            y = end.y;
                            orientation = 'vertical';
                            gameState.openEnds.push({ value: rotatedDomino[1], x: x + 60, y: y + 150 });
                        }
                        
                        // Remove the used end
                        gameState.openEnds.splice(endIndex, 1);
                        
                        // If it's a double, add both ends
                        if (rotatedDomino[0] === rotatedDomino[1]) {
                            if (orientation === 'horizontal') {
                                gameState.openEnds.push(
                                    { value: rotatedDomino[0], x: x + 60, y: y - 30 },
                                    { value: rotatedDomino[1], x: x + 60, y: y + 90 }
                                );
                                orientation = 'vertical';
                            } else {
                                gameState.openEnds.push(
                                    { value: rotatedDomino[0], x: x - 30, y: y + 60 },
                                    { value: rotatedDomino[1], x: x + 90, y: y + 60 }
                                );
                                orientation = 'horizontal';
                            }
                        }
                        
                        // Add to board
                        gameState.board.push({
                            value: rotatedDomino,
                            orientation,
                            x,
                            y
                        });
                        
                        // Remove from computer's hand
                        computer.dominoes.splice(i, 1);
                        
                        // Check for win
                        if (computer.dominoes.length === 0) {
                            endGame(1);
                            return;
                        }
                        
                        played = true;
                        break;
                    }
                }
                
                if (played) break;
            }
            
            if (!played) {
                // Try to draw from stock
                if (gameState.stock.length > 0) {
                    const drawnDomino = gameState.stock.pop();
                    computer.dominoes.push(drawnDomino);
                } else {
                    // Computer passes
                    if (canPass()) {
                        // Do nothing, just switch turns
                    }
                }
            }
            
            // Switch back to player
            gameState.currentPlayer = 0;
            isCurrentPlayer = true;
            
            // Update UI
            updateGameUI();
        }

        // Draw a domino from the stock
        function drawDomino() {
            if (gameState.stock.length === 0) return;
            
            // Take first domino from stock
            const drawnDomino = gameState.stock.pop();
            gameState.players[0].dominoes.push(drawnDomino);
            
            // Update UI
            updateGameUI();
        }

        // Pass turn
        function passTurn() {
            if (!canPass()) return;
            
            // Switch to computer
            gameState.currentPlayer = 1;
            isCurrentPlayer = false;
            
            // Update UI
            updateGameUI();
            
            // Computer's turn
            setTimeout(computerMove, 1000);
        }

        // Check if player can pass
        function canPass() {
            // Can't pass if stock has dominoes left
            if (gameState.stock.length > 0) return false;
            
            // Can't pass if you can play a domino
            const player = gameState.players[gameState.currentPlayer];
            return !player.dominoes.some(domino => 
                gameState.openEnds.some(end => 
                    domino[0] === end.value || domino[1] === end.value
                )
            );
        }

        // End the game
        function endGame(winnerId) {
            // Calculate scores
            const winner = gameState.players[winnerId];
            const loser = gameState.players[winnerId === 0 ? 1 : 0];
            
            // Winner gets points equal to sum of loser's dominoes
            const points = sumDominoes(loser.dominoes);
            winner.score += points;
            
            gameState.gameOver = true;
            gameState.winner = winnerId;
            
            alert(`${winner.name} wins this round with ${points} points!`);
            
            // Start a new round
            startNewRound();
        }

        // Start a new round
        function startNewRound() {
            // Generate new domino set
            const dominoSet = generateDominoSet();
            shuffleArray(dominoSet);

            // Deal dominoes
            gameState.players[0].dominoes = dominoSet.slice(0, 7);
            gameState.players[1].dominoes = dominoSet.slice(7, 14);
            gameState.stock = dominoSet.slice(14);
            gameState.board = [];
            gameState.openEnds = [];
            gameState.gameOver = false;
            
            // Alternate starting player
            gameState.currentPlayer = gameState.winner;
            isCurrentPlayer = gameState.players[gameState.currentPlayer].isHuman;
            
            // Update UI
            updateGameUI();
            
            // If computer starts, make a move
            if (!isCurrentPlayer) {
                setTimeout(computerMove, 1000);
            }
        }

        // Helper functions
        function generateDominoSet() {
            const dominoes = [];
            for (let i = 0; i <= 6; i++) {
                for (let j = i; j <= 6; j++) {
                    dominoes.push([i, j]);
                }
            }
            return dominoes;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function sumDominoes(dominoes) {
            return dominoes.reduce((sum, domino) => sum + domino[0] + domino[1], 0);
        }

        // Initialize the game when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
